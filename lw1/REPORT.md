# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Абдуллаев Е.Н.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Prolog — один из старейших и все еще один из наиболее популярных языков логического программирования, хотя он значительно менее популярен, чем основные императивные языки. Он используется в системах обработки естественных языков, исследованиях искусственного интеллекта, экспертных системах, онтологиях и других предметных областях, для которых естественно использование логической парадигмы.
Структура программы на Прологе отличается от структуры программы, написанной на процедурном языке. Пролог-программа является собранием правил и фактов. Решение задачи достигается интерпретацией этих правил и фактов. При этом пользователю не требуется обеспечивать детальную последовательность инструкций, чтобы указать, каким образом осуществляется управление ходом вычислений на пути к результату. Вместо этого он только определяет возможные решения задачи и обеспечивает программу фактами и правилами, которые позволяют ей отыскать требуемое решение.

## Задание 1.1: Предикат обработки списка

`remove_last([_], []) и remove_last_std(L, R)` - получают последний элемент списка (вариант 2)

Примеры использования:
```prolog
?- remove_last([], X).
false.

?- remove_last([1], X).  
X = [].
      
?- remove_last([100120], _).
true.

?- remove_last([1, 2, 3, 4], X).              
X = [1, 2, 3].

?- remove_last_std([10, 9, 8], X).   
X = [10, 9].

```

Реализация:
```prolog
remove_last([_], []).
remove_last([H|L], [H|R]) :- remove_last(L, R).

%Реализация на основе стандартных предикатов обработки списков
remove_last_std(L, R) :- append(R, [_], L).
```

`remove_last` - получает два аргумента: уменьшаемый список, список для записи оставшейся части.
Пока в исходном списке не останется 1 элемент(1 условие), ставим условие, что элементы исходного и переменной-списка должны совпадать и так проходим по всем

`remove_last_std(L, R)` - L есть конкатенация некоего списка со списком из одного элемента, значение которого нам не важно. Следовательно, R является списком L без одного последнего элемента.

## Задание 1.2: Предикат обработки числового списка

`sorted` - проверяет список на упорядоченность по возрастанию (вариант 7)

Примеры использования:
```prolog
?- sorted([1, 2, 3]).
true.

?- sorted([1, 3, 2]).
false.

?- sorted([1]).
true.

```

Реализация:
```prolog
sorted([]).
sorted([_]).
sorted([X,Y|L]) :- X =< Y, sorted([Y|L]).
    
%Реализация на основе стандартных предикатов обработки списков
unsorted_std(L) :- append(_, [X,Y|_], L), X > Y.
sorted_std(L) :- not(unsorted_std(L)).
```

`sorted` - 3тей строчкой идёт по списку, каждый раз сравнивая 2 элемента. Когда сравнивать будет не с чем, сработает 2я строчка и выдаст true.

`sorted_std` - 1м условием проверяем на условие неотсортированности. Список L является конкатенацией первых двух его элементов X,Y и какого-то списка. Первая строка будет выполняться до того момента, пока есть что сравнивать и каждый раз проверяем меньше ли X чем Y(условие неотсортированности). Потом инвертируем его в условие отсортированности во 2й строке.

## Задание 2: Реляционное представление данных

Модель реляционного представления довольно простая и лёгкая для понимания, что, безусловно, является её плюсом. Из недостатков - могут появится трудности при разработке в достаточно простых местах.

Достоинство, конкретно моего, представления состоит в лёгкости доступа к данным, например, оценкам конкретных студентов.

`get_groups(X)`, где X - список, в который будут записаны группы

Реализация: 

```prolog
get_groups(X) :-
    findall(Group,grade(Group,_,_,_),Markslist), 
    sort(Markslist, X).
```

Пример работы:

```prolog
?- get_groups(X).
X = [101, 102, 103, 104].
```

С помощью команды findall проходимся по всем спискам, каждый раз записывая значения групп в переменную Group для дальнейшего занесения в Marklist, затем сортируем, чтобы также избавиться от повторяющихся значений

`get_subj(X)`, где X - список, в который будут записаны предметы

Реализация: 

```prolog
get_subj(X) :-
    findall(Subj,grade(_,_,Subj,_),Markslist), 
    sort(Markslist, X).
```

Пример работы:

Весьма объёмный, поэтому воздержусь :)

Работает аналогично предыдущему.

`get_marks(X, Y)`, где Y - название предмета, по которому ищем оценки, X - список, куда их запишем

Реализация: 

```prolog
get_marks(X, Y) :-
	findall(Mark,grade(_,_,Y, Mark),X).
```

Пример работы:

Весьма объёмный, поэтому воздержусь :)

Схема работы ясна из описания переменных.

`sum(List, S)`, где List - это список, S - сумма элементов.

Реализация: 

```prolog
sum([], 0).
sum([X|Y], S) :-
    sum(Y, S1),
    S is S1 + X.
```

Пример работы:

```prolog
?- sum([1, 4, 7, 9], X). 
X = 21.
```

Каждый раз отсекаем одно значение в переменную X и прибавляем к S1/S.

`avg(List, S)` - где List - это список, R - среднее арифметическое.

Реализация: 

```prolog
avg([], 0).
avg(L, R) :-
        length(L, Len),
        sum(L, Sum),
        R is Sum / Len.
```

Пример работы:

```prolog
?- avg([1, 4, 7, 9], X).
X = 5.25
```

Берёт длину списка, считает сумму и делит сумму на длину.

`subj_avg(Subj, R)`, где Subj - назвение предмета, R - ср знач по предмету

Реализация: 

```prolog
subj_avg(Subj, R) :- 
    get_marks(Marklist, Subj),
    avg(Marklist, R).
```

Пример работы:

```prolog
?- subj_avg('Психология', X).
X = 3.9285714285714284.
```

Принцип работы следует из описания внутренних предикатов.

`group_not_passed(Group, R)` Group - название группы, R - кол-во несдавших

Реализация: 

```prolog
group_not_passed(Group, R) :-
    findall(Student,grade(Group,Student,_,2),X),
    length(X, R).
```

Пример работы:

```prolog
?- group_not_passed(102, X).
X = 5.
```

Записывает в переменную Student людей с полем 2 в колонке оценок и перенаправляет в список X.

`subj_not_passed(Subj, R))`, где Subj - предмет, R - кол-во несдавших по нему.

Реализация: 

```prolog
subj_not_passed(Subj, R) :-
    findall(Student,grade(_,Student,Subj,2),X),   
    length(X, R).
```

Пример работы:

```prolog
?- subj_not_passed('Информатика', X). 
X = 2.
```

Работает аналогично предыдущему.

`prohod1(List)`, List - список групп.

Реализация: 

```prolog
prohod1([]).
prohod1([H|T]) :- 
    group_not_passed(H, Sum), write("В группе "), write(H),write(" несдавших - "), write(Sum), write("\n"), prohod1(T).
```

Пример работы:

```prolog
?- prohod1([102,103]).  
В группе 102 несдавших - 5 
В группе 103 несдавших - 4
```

Каждый раз отщипывает одну группу и ищет для неё кол-во несдавших с помощью ранее реализованного предиката, затем печатает.

`print1(_)` - печатает несдавших для каждой группы

Реализация: 

```prolog
print1(_) :- 
    get_groups(L1),
    prohod1(L1).
```

Пример работы:

```prolog
?- print1(_). 
В группе 101 несдавших - 2 
В группе 102 несдавших - 5 
В группе 103 несдавших - 4 
В группе 104 несдавших - 2
```

Принцип работы следует из ранее описанных предикатов.

`prohod2(List)`, List - список предметов.

Реализация: 

```prolog
prohod2([]).
prohod2([H|T]) :- 
    subj_not_passed(H, Sum), write("По предмету "), write(H), write(" несдавших - "), write(Sum), write("\n"), prohod2(T).
```

Пример работы:

```prolog
?- prohod2(['Функциональное программирование', 'Логическое программирование']). 
По предмету Функциональное программирование несдавших - 1 
По предмету Логическое программирование несдавших - 2
```

Каждый раз отщипывает один предмет и ищет для него кол-во несдавших с помощью ранее реализованного предиката, затем печатает.

`print2(_)` - печатает несдавших для каждого предмета

Реализация: 

```prolog
print2(_) :- 
    get_subj(L1), 
    prohod2(L1).
```

Пример работы:

```prolog
?- print2(_). 
По предмету Английский язык несдавших - 4 
По предмету Информатика несдавших - 2 
По предмету Логическое программирование несдавших - 2 
По предмету Математический анализ несдавших - 3 
По предмету Психология несдавших - 1 
По предмету Функциональное программирование несдавших - 1
```

Принцип работы следует из ранее описанных предикатов.

`prohod3(List)`, List - список предметов.

Реализация: 

```prolog
prohod3([]).
prohod3([H|T]) :-
    subj_avg(H, Avg), write("По предмету "), write(H), write(" средний балл - "), write(Avg), write("\n"), prohod3(T).
```

Пример работы:

```prolog
?- prohod3(['Английский язык', 'Психология']).  
По предмету Английский язык средний балл - 3.75 
По предмету Психология средний балл - 3.9285714285714284
```

Каждый раз отщипывает один предмет и ищет для него среднее значение с помощью ранее реализованного предиката, затем печатает.

`print3(_)` - печатает средний балл для каждого предмета

Реализация: 

```prolog
print3(_) :- 
    get_subj(L1), 
    prohod3(L1).
```

Пример работы:

```prolog
?- print3(_).
По предмету Английский язык средний балл - 3.75 
По предмету Информатика средний балл - 3.9285714285714284 
По предмету Логическое программирование средний балл - 3.9642857142857144 
По предмету Математический анализ средний балл - 3.892857142857143 
По предмету Психология средний балл - 3.9285714285714284 
По предмету Функциональное программирование средний балл - 3.9642857142857144
```

Принцип работы следует из ранее описанных предикатов.

## Выводы

При выполнении лабораторной работы у меня сложилось ощущение, что весьма проблематично будет каждый день писать на prolog повседневные задачи, уходит много сил, но что более важно времени. В императивных языках просто писать программу шаг за шагом, в логических же каждый этап - это по сути новая формула, которую иногда бывает довольно сложно придумать. С другой стороны, при решении некоторых задач, связанных, например, с логикой и множествами, программа пролога будет выглядеть довольно просто и выполняться очень быстро. Остальные же задания, как, к примеру, второе, связанные с парсингом текста и обработкой каких-либо данных, зачастую проще решаются при помощи императивных языков программирования.

Поначалу я долго не мог понять принцип написания предикатов и долго разбирался с их работой в консоли. Постепенно эмпирическим путём пришло некоторое понимание, но до сих пор ощущается сложность совершенно иного стиля программирования.




